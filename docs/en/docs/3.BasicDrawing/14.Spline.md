# Sample line

We can create a spline object by instantiating an McDbSpline() object. The fitting data of the spline is set by calling the setFitPoints() method of the McDbSpline() instance object to draw the spline. Among them, the parameter data object of setFitPoints() has four attributes, which are respectively:

* degree: The degree of a spline curve, indicating the mathematical order of the curve. Typically, spline curves in AutoCAD are cubic curves (with a degree of 3), meaning they are third-order polynomials.
* fitTolerance: Fitting tolerance, which is a numerical value representing the maximum allowable distance from the fitting point to the actual generated spline curve. A smaller value means that the spline curve will follow the fitting point more closely, but it may lead to a more complex curve.
* tangentsExist: A Boolean value indicating whether the starting tangent and the ending tangent have been specified. If it is true, it indicates that there are custom starting and ending tangent directions, which can control the direction of the curve at the endpoints.
* startTangent: If tangentsExist is true, this parameter is an McGeVector3d object representing the tangent direction of the curve's starting point. It determines the direction at the beginning of the curve.
* endTangent: Similar to startTangent, but if tangentsExist is true, this parameter specifies the direction of the tangent at the end of the curve, affecting how the curve reaches its endpoint.
* fitPoints: This is an array of type McGePoint3dArray, containing a series of three-dimensional points (McGePoint3d), which are the fitting points that the spline curve passes through. Based on the positions of these points, mxcad will calculate a curve that smoothly passes through all the points.

Click [McDbSpline()](../../api/classes/2d.McDbSpline.md)、[setFitPoints()](../../api/classes/2d.McDbSpline.md#setfitpoints) view detailed properties and methods.

```ts
import { MxCpp, MxCADUiPrPoint, McDbSpline, McGePoint3dArray, McGeVector3d } from "mxcad";

// Draw the spline function
async function Mx_drawSpline() {
  const getPoint = new MxCADUiPrPoint();
  getPoint.setMessage("\n specifies the first point:");
  let prvPoint = await getPoint.go();
  if (!prvPoint) return;
  getPoint.setMessage("\n specifies the next point:");
  let fitPoints = new McGePoint3dArray();
  fitPoints.append(prvPoint);
//  Sampling points in a spline loop
  while (true) {
    getPoint.setBasePt(prvPoint as any);
    if (fitPoints.length() == 1) {
      getPoint.setUseBasePt(true);
    } else {
      getPoint.setUseBasePt(false);
      getPoint.setUserDraw((pt, pw) => {
        let tmpFitPoints = new McGePoint3dArray();
        tmpFitPoints.copy(fitPoints);
        tmpFitPoints.append(pt);
        // Create a spline
        let tmpSPline = new McDbSpline();
        tmpSPline.setFitPoints({
          degree: 3,
          fitTolerance: 0.000001,
          tangentsExist: false,
          startTangent: McGeVector3d.kIdentity,
          endTangent: McGeVector3d.kIdentity,
          fitPoints: tmpFitPoints,
        });
        pw.drawMcDbEntity(tmpSPline);
      });
    }

    let pt = await getPoint.go();
    if (!pt) break;
    fitPoints.append(pt);
    prvPoint = pt;
  }

  if (fitPoints.length() > 2) {
    let sp = new McDbSpline();
    sp.setFitPoints({
      degree: 3,
      fitTolerance: 0.000001,
      tangentsExist: false,
      startTangent: McGeVector3d.kIdentity,
      endTangent: McGeVector3d.kIdentity,
      fitPoints: fitPoints,
    });
    MxCpp.getCurrentMxCAD().drawEntity(sp);
  }
}
```
:::demo

```tsx
import { MxFun } from "mxdraw"
import { MxCpp, MxCADUiPrPoint, McDbSpline, McGePoint3dArray, McGeVector3d, McObject, McGePoint3d } from "mxcad"

export default () => {
    const mxcad = new McObject()
    mxcad.create({
      canvas: "#myCanvas",
      locateFile: (fileName: string)=> {
            // CDN loading must use the resources in wasm/ 2d-ST. Due to github's restrictions, wasm/2d resources cannot be used
            // If you need to use wasm/2d, you must follow the browser's same-origin policy or use other means to circumvent it
            return self.location.origin + "/mxcad_docs/wasm/2d-st/" + fileName
      },
      // The directory location where the font is loaded
      fontspath: self.location.origin + "/mxcad_docs/fonts",
      // Load the converted drawing file
      fileUrl: self.location.origin + "/mxcad_docs/test.mxweb",
      onOpenFileComplete: ()=>{
        // Draw a sample line
        const sp = new McDbSpline();
        const fitPoints = new McGePoint3dArray([new McGePoint3d(0,-20,0), new McGePoint3d(20,20,0), new McGePoint3d(40,-20,0), new McGePoint3d(60,20,0), new McGePoint3d(80,-20,0), new McGePoint3d(100,20,0)]);
        sp.setFitPoints({ degree: 3, fitTolerance: 0.000001, tangentsExist: false, startTangent: McGeVector3d.kIdentity, endTangent: McGeVector3d.kIdentity, fitPoints: fitPoints });
        const mxcad = MxCpp.getCurrentMxCAD();
        mxcad.drawEntity(sp);
        mxcad.zoomAll();
      }
    })
// Draw the spline function
async function Mx_drawSpline() {
    const getPoint = new MxCADUiPrPoint();
    getPoint.setMessage("\n Specify the first point:");
    let prvPoint = await getPoint.go();
    if (!prvPoint) return;
    getPoint.setMessage("\n Specify the next point:");
    let fitPoints = new McGePoint3dArray();
    fitPoints.append(prvPoint)

    while (true) {
        getPoint.setBasePt(prvPoint as any);
        if (fitPoints.length() == 1) {
            getPoint.setUseBasePt(true);
        }
        else {
            getPoint.setUseBasePt(false);
            getPoint.setUserDraw((pt, pw) => {

                let tmpFitPoints = new McGePoint3dArray();
                tmpFitPoints.copy(fitPoints);
                tmpFitPoints.append(pt);

                let tmpSPline = new McDbSpline();
                tmpSPline.setFitPoints({
                    degree: 3, fitTolerance: 0.000001, tangentsExist: false, startTangent: McGeVector3d.kIdentity, endTangent: McGeVector3d.kIdentity,
                    fitPoints: tmpFitPoints
                });
                pw.drawMcDbEntity(tmpSPline);

            });
        }
        let pt = await getPoint.go();
        if (!pt) break;

        fitPoints.append(pt);
        prvPoint = pt;
    }

    if (fitPoints.length() > 2) {
        let sp = new McDbSpline();
        sp.setFitPoints({ degree: 3, fitTolerance: 0.000001, tangentsExist: false, startTangent: McGeVector3d.kIdentity, endTangent: McGeVector3d.kIdentity, fitPoints: fitPoints });
        MxCpp.getCurrentMxCAD().drawEntity(sp);
    }
    }
    return (<div style="height: 500px; overflow: hidden;">
      <button style="height:30px;border:1px solid #ccc;padding:0px 5px;margin-bottom:10px"
      id="myBtn" onClick={()=>Mx_Test_DrawImage()}>Draw spline lines</button>
      <div style="height: 400px;"><canvas id="myCanvas" style="height: 300px"></canvas></div>
    </div>)
}
```
:::

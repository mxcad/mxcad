# 样条线

我们可以通过实例化一个 McDbSpline() 对象创建样条线对象。通过调用 McDbSpline() 实例对象的 setFitPoints() 方法来设置样条线的拟合数据绘制样条线。其中，setFitPoints()的参数 data 对象中有四个属性，它们分别是：

- degree: 样条曲线的次数（degree），表示曲线的数学阶次。通常，AutoCAD 中的样条曲线是三次曲线（degree 为 3），意味着它们是三阶多项式。
- fitTolerance: 拟合公差，这是一个数值，代表了拟合点到实际生成的样条曲线之间的最大允许距离。较小的值意味着样条曲线将更紧密地跟随拟合点，但可能会导致曲线更加复杂。
- tangentsExist: 一个布尔值，指示是否指定了起点切线和终点切线。如果为 true，则表示存在自定义的起始和结束切线方向，这可以控制曲线在端点处的方向。
- startTangent: 如果 tangentsExist 为 true，此参数是一个 McGeVector3d 对象，表示曲线起点的切线方向。它决定了曲线开始时的方向。
- endTangent: 类似于 startTangent，但如果 tangentsExist 为 true，这个参数指定的是曲线结束时的切线方向，影响曲线如何到达其终点。
- fitPoints: 这是一个 McGePoint3dArray 类型的数组，包含了一系列的三维点(McGePoint3d)，这些点是样条曲线要经过的拟合点。根据这些点的位置，mxcad 会计算出一条平滑通过所有点的曲线。

点击 [McDbSpline()](../../api/classes/2d.McDbSpline.md)、[setFitPoints()](../../api/classes/2d.McDbSpline.md#setfitpoints) 查看详细属性和方法说明。

```ts
import { MxCpp, MxCADUiPrPoint, McDbSpline, McGePoint3dArray, McGeVector3d } from "mxcad";

// 绘样条线函数
async function Mx_drawSpline() {
  const getPoint = new MxCADUiPrPoint();
  getPoint.setMessage("\n指定第一点:");
  let prvPoint = await getPoint.go();
  if (!prvPoint) return;
  getPoint.setMessage("\n指定下一个点:");
  let fitPoints = new McGePoint3dArray();
  fitPoints.append(prvPoint);
//  样条线循环取点
  while (true) {
    getPoint.setBasePt(prvPoint as any);
    if (fitPoints.length() == 1) {
      getPoint.setUseBasePt(true);
    } else {
      getPoint.setUseBasePt(false);
      getPoint.setUserDraw((pt, pw) => {
        let tmpFitPoints = new McGePoint3dArray();
        tmpFitPoints.copy(fitPoints);
        tmpFitPoints.append(pt);
        // 创建样条线
        let tmpSPline = new McDbSpline();
        tmpSPline.setFitPoints({
          degree: 3,
          fitTolerance: 0.000001,
          tangentsExist: false,
          startTangent: McGeVector3d.kIdentity,
          endTangent: McGeVector3d.kIdentity,
          fitPoints: tmpFitPoints,
        });
        pw.drawMcDbEntity(tmpSPline);
      });
    }

    let pt = await getPoint.go();
    if (!pt) break;
    fitPoints.append(pt);
    prvPoint = pt;
  }

  if (fitPoints.length() > 2) {
    let sp = new McDbSpline();
    sp.setFitPoints({
      degree: 3,
      fitTolerance: 0.000001,
      tangentsExist: false,
      startTangent: McGeVector3d.kIdentity,
      endTangent: McGeVector3d.kIdentity,
      fitPoints: fitPoints,
    });
    MxCpp.getCurrentMxCAD().drawEntity(sp);
  }
}
```
:::demo

```tsx
import { MxFun } from "mxdraw"
import { MxCpp, MxCADUiPrPoint, McDbSpline, McGePoint3dArray, McGeVector3d, McObject, McGePoint3d } from "mxcad"

export default () => {
    const mxcad = new McObject()
    mxcad.create({
      canvas: "#myCanvas",
      locateFile: (fileName: string)=> {
            // CDN 加载必须使用wasm/2d-st中的资源、因为github的限制无法使用wasm/2d 资源
            // 需要使用wasm/2d需要遵循浏览器同源策略或使用其他手段规避浏览器同源策略
            return self.location.origin + "/mxcad_docs/wasm/2d-st/" + fileName
      },
      // 加载字体的目录位置
      fontspath: self.location.origin + "/mxcad_docs/fonts",
      // 加载转换后的图纸文件
      fileUrl: self.location.origin + "/mxcad_docs/test.mxweb",
      onOpenFileComplete: ()=>{
        // 绘制一条样条线
        const sp = new McDbSpline();
        const fitPoints = new McGePoint3dArray([new McGePoint3d(0,-20,0), new McGePoint3d(20,20,0), new McGePoint3d(40,-20,0), new McGePoint3d(60,20,0), new McGePoint3d(80,-20,0), new McGePoint3d(100,20,0)]);
        sp.setFitPoints({ degree: 3, fitTolerance: 0.000001, tangentsExist: false, startTangent: McGeVector3d.kIdentity, endTangent: McGeVector3d.kIdentity, fitPoints: fitPoints });
        const mxcad = MxCpp.getCurrentMxCAD();
        mxcad.drawEntity(sp);
        mxcad.zoomAll();
      }
    })
// 绘样条线函数
async function Mx_drawSpline() {
    const getPoint = new MxCADUiPrPoint();
    getPoint.setMessage("\n指定第一点:");
    let prvPoint = await getPoint.go();
    if (!prvPoint) return;
    getPoint.setMessage("\n指定下一个点:");
    let fitPoints = new McGePoint3dArray();
    fitPoints.append(prvPoint)

    while (true) {
        getPoint.setBasePt(prvPoint as any);
        if (fitPoints.length() == 1) {
            getPoint.setUseBasePt(true);
        }
        else {
            getPoint.setUseBasePt(false);
            getPoint.setUserDraw((pt, pw) => {

                let tmpFitPoints = new McGePoint3dArray();
                tmpFitPoints.copy(fitPoints);
                tmpFitPoints.append(pt);

                let tmpSPline = new McDbSpline();
                tmpSPline.setFitPoints({
                    degree: 3, fitTolerance: 0.000001, tangentsExist: false, startTangent: McGeVector3d.kIdentity, endTangent: McGeVector3d.kIdentity,
                    fitPoints: tmpFitPoints
                });
                pw.drawMcDbEntity(tmpSPline);

            });
        }
        let pt = await getPoint.go();
        if (!pt) break;

        fitPoints.append(pt);
        prvPoint = pt;
    }

    if (fitPoints.length() > 2) {
        let sp = new McDbSpline();
        sp.setFitPoints({ degree: 3, fitTolerance: 0.000001, tangentsExist: false, startTangent: McGeVector3d.kIdentity, endTangent: McGeVector3d.kIdentity, fitPoints: fitPoints });
        MxCpp.getCurrentMxCAD().drawEntity(sp);
    }
    }
    return (<div style="height: 500px; overflow: hidden;">
      <button style="height:30px;border:1px solid #ccc;padding:0px 5px;margin-bottom:10px"
      id="myBtn" onClick={()=>Mx_Test_DrawImage()}>绘制样条线</button>
      <div style="height: 400px;"><canvas id="myCanvas" style="height: 300px"></canvas></div>
    </div>)
}
```
:::
